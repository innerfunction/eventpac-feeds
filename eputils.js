var q = require('semo/lib/q');
var format = require('util').format;

// Functions for generating EP URIs, by scheme.
exports.schemes = function( feedid ) {
    var schemes = {
        'subs': function() {
            return this.href()
            .then(function( href ) {
                return format('subs:/%s/%s', feedid, href );
            });
        }
    };
    return schemes;
}

// Function for generating an action URI.
// @viewName:   An EP view name.
// @viewParams: An object mapping parameter names to values. Values may be deferred promises.
exports.action = function( viewName, viewParams ) {
    var params = Object.keys( viewParams )
    .map(function( name ) {
        return q.Q( viewParams[name] )
        .then(function( value ) {
            return [ name, value ];
        });
    });
    return q.all( params )
    .then(function( params ) {
        params = params.reduce(function( result, param ) {
            return result+'+'+param[0]+'@'+param[1];
        }, '');
        return format('nav/open+view@%s%s', viewName, params );
    });
}

var utils = require('semo-build/lib/utils');

// Merge a partial DB update into the complete DB record.
// A partial DB update is one generated by an incremental build, when only some records
// are updated, but non-updated records may still be active. The two arguments are in
// the same format as used by diffDBUpdates(). The partial argument may specify records
// for deletion by mapping their record ID to null or false. The partial argument may
// contain properties mapped to deferred promises; these will be resolved before the
// merge takes place. The function returns a deferred promise resolving to the new
// set of complete DB updates.
// Use this function from within a build script performing an incremental build.
exports.mergeDBUpdates = function( complete, partial ) {
    complete = complete||{};
    // Stringify and re-parse the partial argument, to resolve any deferred promises.
    utils.resolveAllPromises( partial )
    .then(function( partial ) {
        // Iterate over the tables in the partial update.
        for( var table in partial ) {
            var partialTable = partial[table];
            var completeTable = complete[table];
            if( completeTable ) {
                // Iterate over the record IDs in the partial update.
                for( var recordID in partialTable ) {
                    // If the record ID is mapped to null/false, then delete from the complete set.
                    if( !partialTable[recordID] ) {
                        delete complete[recordID];
                    }
                    else {
                        // ...else copy the updated record to the complete set.
                        complete[recordID] = partial[recordID];
                    }
                }
            }
            else {
                // If table not found in complete set then copy the full update, less any deletions.
                completeTable = {};
                for( var recordID in partialTable ) {
                    if( partialTable[recordID] ) {
                        completeTable[recordID] = partialTable[recordID];
                    }
                }
                complete[table] = completeTable;
            }
        }
        return complete;
    });
}
